---
layout: post
title: 2019 Hackcon Writeup
author: "Realsung"
comments: true
featured: true
sitemap :
  changefreq : 2019 Hackcon
  priority : 1.0
---

# Reversing

## babyrev

우선 main을 보면 Password를 체크해주고 맞는지 안 맞는지 체크해주지도 않는다.

```c
int __cdecl main(int argc, const char **argv, const char **envp)
{
  __printf_chk(1LL, "Password : ", envp);
  fflush(stdout);
  return read(0, &user, 0x3E8uLL);
}
```

check 함수가 따로 있는데 메인 이전에 호출 되는거 같다.

```c
unsigned __int64 check()
{
  __m128i v1; // [rsp+0h] [rbp-78h]
  char v2; // [rsp+10h] [rbp-68h]
  char v3; // [rsp+11h] [rbp-67h]
  char v4; // [rsp+12h] [rbp-66h]
  int v5; // [rsp+60h] [rbp-18h]
  unsigned __int64 v6; // [rsp+68h] [rbp-10h]

  v6 = __readfsqword(0x28u);
  memset(&v1, 0, 0x60uLL);
  v5 = 0;
  if ( result )
  {
    v1 = _mm_load_si128(&xmmword_55EE0F1C9AF0); // wrong
  }
  else
  {
    v2 = 't';
    v3 = 'e';
    v1 = _mm_load_si128(&xmmword_55EE0F1C9B00); // correct
    v4 = 's';
  }
  puts(v1.m128i_i8);
  return __readfsqword(0x28u) ^ v6;
}
```

begin함수도 main전에 호출되고 pass를 미리 할당해준다.

```c
void begin()
{
  byte_55EE0F3CA460 = 59;
  byte_55EE0F3CA461 = 56;
  pass = _mm_load_si128(&xmmword_55EE0F1C9AE0);
  byte_55EE0F3CA462 = 60;
}
```

end() 함수를 보면 password를 역연산해서 구할 수 있다.

```c
__int64 end()
{
  signed __int64 v0; // rdx
  __int64 result; // rax
  int v2; // eax
  int v3; // eax
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // eax
  int v10; // er10

  v0 = 1LL;
  LODWORD(result) = (pass ^ *ruser) ^ 0x41;
  LOBYTE(result) = ::result | pass ^ *ruser ^ 0x41;
  ::result |= (pass ^ *ruser) ^ 0x41;
  do
  {
    v2 = (*(&pass + v0) ^ *(ruser + v0)) ^ 0x41 | result;
    ::result = v2;
    v3 = (*(&pass + v0 + 1) ^ *(ruser + v0 + 1)) ^ 0x41 | v2;
    ::result = v3;
    v4 = (*(&pass + v0 + 2) ^ *(ruser + v0 + 2)) ^ 0x41 | v3;
    ::result = v4;
    v5 = (*(&pass + v0 + 3) ^ *(ruser + v0 + 3)) ^ 0x41 | v4;
    ::result = v5;
    v6 = (*(&pass + v0 + 4) ^ *(ruser + v0 + 4)) ^ 0x41 | v5;
    ::result = v6;
    v7 = (*(&pass + v0 + 5) ^ *(ruser + v0 + 5)) ^ 0x41 | v6;
    ::result = v7;
    v8 = (*(&pass + v0 + 6) ^ *(ruser + v0 + 6)) ^ 0x41 | v7;
    ::result = v8;
    v9 = (*(&pass + v0 + 7) ^ *(ruser + v0 + 7)) ^ 0x41 | v8;
    ::result = v9;
    v10 = (*(&pass + v0 + 8) ^ *(ruser + v0 + 8));
    v0 += 9LL;
    result = v10 ^ 0x41 | v9;
    ::result = result;
  }
  while ( v0 != 19 );
  return result;
}
```

```python
# table = pass
table=[0x27,0x2d,0x20,0x26,0x3a,0x15,0x29,0x70,0x74,0x1e,0x70,0x74,0x1e,0x02,0x33,0x75,0x3b,0x38,0x3c]
flag = ""
for i in range(len(table)):
	flag += chr(table[i] ^ 0x41)
print flag
```

스크립트를 실행하게 되면 `flag{Th15_15_Cr4zy}` 가 뜬다.

![](https://user-images.githubusercontent.com/32904385/63637975-b63bc600-c6bd-11e9-892a-8184140f28b1.png)

디버깅해서 보면 16글자 이후에 입력되는 값을 가져와서 체크한다. 그러므로 아무거나 16Byte를 입력해주고 플래그를 입력해주면 정상적으로 맞다고 뜰 것이다. Wrong , Password가 안 뜨는 것을 확인 할 수 있다.

![](https://user-images.githubusercontent.com/32904385/63638016-24808880-c6be-11e9-9384-6f6fde2cdfaf.png)

**FLAG : `flag{Th15_15_Cr4zy}`**

